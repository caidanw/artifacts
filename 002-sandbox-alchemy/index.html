<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="created" content="2025-10-28" />
    <title>Sandbox Alchemy</title>
    <link rel="stylesheet" href="../reset.css" />
    <link rel="stylesheet" href="../global.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #1a1a2e;
        color: #fff;
        overflow: hidden;
        height: 100vh;
      }

      #gameContainer {
        display: grid;
        grid-template-columns: 1fr 400px;
        grid-template-rows: auto 1fr;
        height: 100vh;
        gap: 20px;
        padding: 20px;
      }

      #header {
        grid-column: 1 / -1;
        text-align: center;
        background: rgba(10, 10, 30, 0.95);
        padding: 15px;
        border-radius: 8px;
        border: 2px solid #4a5568;
      }

      #canvasWrapper {
        position: relative;
        background: #0f0f1e;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        border: 2px solid #4a5568;
        min-height: 0;
      }

      #gameCanvas {
        border: 3px solid #4a5568;
        border-radius: 8px;
        cursor: crosshair;
        background: #16213e;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        max-width: 100%;
        max-height: 100%;
      }

      #controlsPanel {
        background: rgba(10, 10, 30, 0.95);
        border-radius: 8px;
        border: 2px solid #4a5568;
        display: grid;
        grid-template-rows: auto auto 1fr auto;
        gap: 15px;
        padding: 20px;
        overflow: hidden;
      }

      #quickStats {
        background: rgba(255, 255, 255, 0.05);
        padding: 15px;
        border-radius: 8px;
      }

      #materialControls {
        background: rgba(255, 255, 255, 0.05);
        padding: 15px;
        border-radius: 8px;
      }

      #gameActions {
        overflow-y: auto;
        padding-right: 10px;
      }

      #gameActions::-webkit-scrollbar {
        width: 8px;
      }

      #gameActions::-webkit-scrollbar-track {
        background: #1a1a2e;
        border-radius: 4px;
      }

      #gameActions::-webkit-scrollbar-thumb {
        background: #4a5568;
        border-radius: 4px;
      }

      #bottomControls {
        background: rgba(255, 255, 255, 0.05);
        padding: 15px;
        border-radius: 8px;
      }

      h1 {
        font-size: 28px;
        margin: 0;
        color: #ffd700;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      }

      h2 {
        font-size: 16px;
        margin: 0 0 10px 0;
        color: #ffd700;
      }

      #stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
      }

      .stat {
        background: rgba(255, 255, 255, 0.05);
        padding: 10px;
        border-radius: 6px;
        text-align: center;
      }

      .stat-label {
        display: block;
        color: #a0aec0;
        font-size: 12px;
        margin-bottom: 4px;
      }

      .stat-value {
        display: block;
        color: #ffd700;
        font-weight: bold;
        font-size: 16px;
      }

      #currentMaterial {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        margin-bottom: 20px;
      }

      #currentMaterial h3 {
        font-size: 14px;
        margin-bottom: 5px;
        opacity: 0.8;
      }

      #materialName {
        font-size: 20px;
        font-weight: bold;
      }

      .section {
        margin-bottom: 20px;
      }

      .section h3 {
        color: #a0aec0;
        font-size: 13px;
        text-transform: uppercase;
        margin-bottom: 10px;
        letter-spacing: 1px;
      }

      .material-btn,
      .upgrade-btn,
      .dropper-btn {
        width: 100%;
        padding: 12px;
        margin-bottom: 8px;
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.05);
        color: white;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        justify-content: space-between;
        align-items: center;
        text-align: left;
      }

      .material-btn:hover,
      .upgrade-btn:hover:not(:disabled),
      .dropper-btn:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(102, 126, 234, 0.5);
      }

      .material-btn.selected {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-color: #667eea;
      }

      .material-btn.locked,
      .upgrade-btn:disabled,
      .dropper-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .material-btn.locked:hover {
        background: rgba(255, 255, 255, 0.05);
        border-color: rgba(255, 255, 255, 0.1);
      }

      .material-cost,
      .upgrade-cost {
        background: rgba(0, 0, 0, 0.3);
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 12px;
      }

      .upgrade-header {
        display: flex;
        justify-content: space-between;
        width: 100%;
        margin-bottom: 4px;
      }

      .upgrade-level {
        background: rgba(255, 215, 0, 0.3);
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 11px;
      }

      .upgrade-desc {
        font-size: 11px;
        color: #a0aec0;
        margin-bottom: 4px;
      }

      .upgrade-btn-content {
        width: 100%;
      }

      .action-btn {
        width: 100%;
        padding: 12px;
        margin-bottom: 8px;
        border: none;
        border-radius: 6px;
        background: rgba(255, 100, 100, 0.3);
        color: white;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
      }

      .action-btn:hover {
        background: rgba(255, 100, 100, 0.5);
      }

      .action-btn:active {
        transform: scale(0.95);
      }

      .info {
        background: rgba(255, 255, 255, 0.05);
        padding: 10px;
        border-radius: 6px;
        font-size: 12px;
        color: #a0aec0;
        line-height: 1.5;
      }

      #brushSize {
        width: 100%;
        margin: 10px 0;
      }

      .brush-label {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #a0aec0;
        margin-bottom: 5px;
      }

       /* Responsive design */
       @media (max-width: 1200px) {
         #gameContainer {
           grid-template-columns: 1fr 350px;
           gap: 15px;
           padding: 15px;
         }

         #controlsPanel {
           padding: 15px;
         }
       }

       @media (max-width: 900px) {
         #gameContainer {
           grid-template-columns: 1fr;
           grid-template-rows: auto auto auto;
           gap: 15px;
         }

         #controlsPanel {
           grid-row: 3;
           max-height: 400px;
         }

         #stats {
           grid-template-columns: repeat(3, 1fr);
         }
       }

       @media (max-width: 600px) {
         body {
           overflow-x: hidden;
         }

         #gameContainer {
           padding: 10px;
           gap: 10px;
         }

         #header h1 {
           font-size: 24px;
         }

         #stats {
           grid-template-columns: 1fr;
           gap: 8px;
         }

         .material-btn,
         .upgrade-btn,
         .dropper-btn {
           padding: 10px;
           font-size: 13px;
         }
       }

        /* Discovery notification animation */
        @keyframes fadeInOut {
          0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
          15% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
          20% { transform: translate(-50%, -50%) scale(1); }
          80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
          100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        /* Prestige panel styling */
        #prestigePanel {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          padding: 15px;
          border-radius: 8px;
          margin-top: 20px;
          border: 2px solid rgba(255, 255, 255, 0.2);
        }

        #prestigePanel h2 {
          margin: 0 0 15px 0;
          text-align: center;
          font-size: 18px;
        }

        #prestigeStats {
          margin-bottom: 15px;
        }

        #prestigeStats .stat {
          margin-bottom: 8px;
        }

        #prestigeButton {
          width: 100%;
          padding: 15px;
          border: 2px solid rgba(255, 255, 255, 0.3);
          border-radius: 8px;
          background: linear-gradient(135deg, #e67e22 0%, #f39c12 100%);
          color: white;
          font-weight: bold;
          cursor: pointer;
          transition: all 0.3s;
          text-align: center;
        }

        #prestigeButton:hover:not(.disabled) {
          background: linear-gradient(135deg, #d35400 0%, #e67e22 100%);
          transform: translateY(-2px);
          box-shadow: 0 4px 15px rgba(230, 126, 34, 0.4);
        }

        #prestigeButton.disabled {
          background: rgba(255, 255, 255, 0.1);
          border-color: rgba(255, 255, 255, 0.1);
          cursor: not-allowed;
          opacity: 0.5;
        }

        .upgrade-name {
          font-size: 16px;
          margin-bottom: 5px;
        }

        .upgrade-desc {
          font-size: 12px;
          opacity: 0.9;
          margin-bottom: 5px;
        }

        .upgrade-cost {
          font-size: 14px;
          font-weight: bold;
        }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <div id="header">
        <h1>🧪 Sandbox Alchemy</h1>
        <p style="margin: 0; color: #a0aec0; font-size: 14px">
          Create, combine, and collect materials in your magical sandbox!
        </p>
      </div>

      <div id="canvasWrapper">
        <canvas id="gameCanvas" width="600" height="500"></canvas>
      </div>

      <div id="controlsPanel">
         <div id="quickStats">
           <h2>📊 Game Stats</h2>
           <div id="stats">
             <div class="stat">
               <span class="stat-label">Sand Collected:</span>
               <span class="stat-value" id="sandCount">0</span>
             </div>
             <div class="stat">
               <span class="stat-label">Sand/sec:</span>
               <span class="stat-value" id="sandPerSec">0.0</span>
             </div>
             <div class="stat">
               <span class="stat-label">Auto-Clickers:</span>
               <span class="stat-value" id="autoClickerCount">0</span>
             </div>
              <div class="stat">
                <span class="stat-label">Particles:</span>
                <span class="stat-value" id="particleCount">0</span>
              </div>
            </div>
          </div>

          <div id="prestigePanel">
            <h2>🌟 Dimensional Shift</h2>
            <div id="prestigeStats">
              <div class="stat">
                <span class="stat-label">Catalysts:</span>
                <span class="stat-value" id="catalystCount">0</span>
              </div>
              <div class="stat">
                <span class="stat-label">Collection Bonus:</span>
                <span class="stat-value" id="collectionBonus">+0%</span>
              </div>
              <div class="stat">
                <span class="stat-label">Total Sand Lifetime:</span>
                <span class="stat-value" id="totalSandLifetime">0</span>
              </div>
            </div>
            <div id="prestigeButton" class="upgrade-button disabled" onclick="attemptPrestige()">
              <div class="upgrade-name">🌌 Dimensional Shift</div>
              <div class="upgrade-desc">Reset reality for Catalysts (Requires 10,000 sand)</div>
              <div class="upgrade-cost">+<span id="prestigeGain">0</span> Catalysts</div>
            </div>
          </div>

        <div id="materialControls">
          <div id="currentMaterial">
            <h3>Current Material</h3>
            <div id="materialName">🟡 Sand (Free)</div>
          </div>

          <div style="margin-top: 15px">
            <h3
              style="
                margin: 0 0 8px 0;
                color: #a0aec0;
                font-size: 13px;
                text-transform: uppercase;
                letter-spacing: 1px;
              "
            >
              ⚙️ Brush Size
            </h3>
            <div class="brush-label">
              <span>Size:</span>
              <span id="brushSizeValue">1</span>
            </div>
            <input type="range" id="brushSize" min="1" max="5" value="1" />
          </div>
        </div>

        <div id="gameActions">
          <div class="section">
            <h3>⚡ Upgrades</h3>
            <div id="upgradesContainer"></div>
          </div>

          <div class="section">
            <h3>🏭 Auto-Droppers</h3>
            <div id="droppersContainer"></div>
          </div>

          <div class="section">
            <h3>🎨 Basic Materials</h3>
            <button class="material-btn selected" data-material="sand">
              <span>🟡 Sand (Free to place)</span>
              <span class="material-cost">Free</span>
            </button>
            <button
              class="material-btn locked"
              data-material="water"
            >
              <span>💧 Water (2 sand/use)</span>
              <span class="material-cost">50 sand</span>
            </button>
            <button
              class="material-btn locked"
              data-material="stone"
            >
              <span>⚫ Stone (5 sand/use)</span>
              <span class="material-cost">100 sand</span>
            </button>
          </div>

          <div class="section">
            <h3>🔥 Advanced Materials</h3>
            <button
              class="material-btn locked"
              data-material="fire"
            >
              <span>🔥 Fire (3 sand/use)</span>
              <span class="material-cost">200 sand</span>
            </button>
            <button
              class="material-btn locked"
              data-material="wood"
            >
              <span>🟫 Wood (4 sand/use)</span>
              <span class="material-cost">150 sand</span>
            </button>
            <button
              class="material-btn locked"
              data-material="oil"
            >
              <span>🟤 Oil (6 sand/use)</span>
              <span class="material-cost">300 sand</span>
            </button>
            <button
              class="material-btn locked"
              data-material="steam"
            >
              <span>💨 Steam (2 sand/use)</span>
              <span class="material-cost">250 sand</span>
            </button>
          </div>

          <div class="info">
            <strong>💡 Idle Game Tips:</strong><br />
            • Buy Auto-Clickers for passive sand generation<br />
            • Upgrades compound for exponential growth<br />
            • Experiment with material combinations!<br />
            • Ember particles provide passive income<br />
            <br />
            <strong>🔬 Enhanced Material Reactions:</strong><br />
            • Sand + Water = Mud (3x value)<br />
            • Sand + Fire = Glass (10x value!)<br />
            • Oil + Fire = Explosion (25x burst!)<br />
            • Wood + Fire = Ember (passive income)<br />
            • Stone + Fire = Obsidian (5x platform)<br />
            • Discover more combinations for bonuses!
          </div>
        </div>

        <div id="bottomControls">
          <h3
            style="
              margin: 0 0 10px 0;
              color: #a0aec0;
              font-size: 13px;
              text-transform: uppercase;
              letter-spacing: 1px;
            "
          >
            🗑️ Actions
          </h3>
          <button class="action-btn" id="clearBtn">Clear Sandbox</button>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      const CELL_SIZE = 4;
      const COLS = Math.floor(canvas.width / CELL_SIZE);
      const ROWS = Math.floor(canvas.height / CELL_SIZE);

      // Game state
      const game = {
        sandCollected: 100, // Give starting sand for testing
        currentMaterial: "sand",
        brushSize: 1,
        unlockedMaterials: new Set(["sand"]),
        grid: Array(ROWS)
          .fill()
          .map(() => Array(COLS).fill(null)),
        mouseDown: false,
        mouseX: 0,
        mouseY: 0,
        clickPower: 1,
        collectionMultiplier: 1,
        collectionSpeed: 0.005, // Slower base collection
        droppers: [],
        sandPerSecTracker: [],
        lastSandCount: 0,
        // New idle game mechanics
        autoClickers: 0,
        autoClickerPower: 1,
        autoClickerSpeed: 180, // frames between auto clicks (3 seconds)
        autoClickerTimer: 0,
        research: {
          autoCollection: 0,
          materialEfficiency: 0,
          reactionSpeed: 0,
          automation: 0
        },
        reactions: new Map(), // Track active reactions
        materialCombos: new Map(), // Track discovered combinations
        prestige: {
          catalysts: 0,
          totalSandLifetime: 0, // Total sand collected across all runs
          currentRunSand: 0,    // Sand collected this run only
          hasPrestiged: false   // Track if player has ever prestiged
        }
      };

      // Upgrades definition - Rebalanced for idle game
      const upgrades = {
        autoClicker: {
          name: "Auto Clicker",
          description: "Automatically places sand particles",
          level: 0,
          baseCost: 100,
          costMultiplier: 2.5,
          effect: (level) => level,
          icon: "🤖",
        },
        clickPower: {
          name: "Click Power",
          description: "Drop more particles per click",
          level: 0,
          baseCost: 50,
          costMultiplier: 2,
          effect: (level) => level + 1,
          icon: "👆",
        },
        collectionMultiplier: {
          name: "Collection Bonus",
          description: "Multiply sand collected",
          level: 0,
          baseCost: 150,
          costMultiplier: 3,
          effect: (level) => Math.pow(1.5, level),
          icon: "💰",
        },
        collectionSpeed: {
          name: "Collection Speed",
          description: "Collect sand faster at bottom",
          level: 0,
          baseCost: 200,
          costMultiplier: 2.2,
          effect: (level) => 0.005 + level * 0.005,
          icon: "⚡",
        },
        reactionEfficiency: {
          name: "Reaction Catalyst",
          description: "Increase material reaction rates",
          level: 0,
          baseCost: 500,
          costMultiplier: 3,
          effect: (level) => 1 + level * 0.5,
          icon: "🧪",
        },
        automationSpeed: {
          name: "Automation Speed",
          description: "Auto-clickers and droppers work faster",
          level: 0,
          baseCost: 750,
          costMultiplier: 2.5,
          effect: (level) => Math.max(0.5, 1 - level * 0.1),
          icon: "⚙️",
        },
      };

      // Dropper types - Rebalanced for idle progression
      const dropperTypes = {
        basic: {
          name: "Basic Dropper",
          cost: 300,
          interval: 300, // 5 seconds between drops
          dropAmount: 1,
          icon: "🟡",
          color: "#667eea",
        },
        advanced: {
          name: "Advanced Dropper",
          cost: 1500,
          interval: 240, // 4 seconds
          dropAmount: 2,
          icon: "🟢",
          color: "#48bb78",
        },
        mega: {
          name: "Mega Dropper",
          cost: 7500,
          interval: 180, // 3 seconds
          dropAmount: 4,
          icon: "🔵",
          color: "#9f7aea",
        },
        quantum: {
          name: "Quantum Dropper",
          cost: 50000,
          interval: 120, // 2 seconds
          dropAmount: 8,
          icon: "⚡",
          color: "#ffd700",
        },
      };

      // Material definitions - Enhanced for meaningful interactions
      const materials = {
        sand: {
          name: "🟡 Sand",
          color: "#f4d03f",
          density: 3,
          fallSpeed: 1,
          spreadChance: 0.5,
          flammable: false,
          liquid: false,
          placementCost: 0,
          unlockCost: 0,
          baseValue: 1,
        },
        water: {
          name: "💧 Water",
          color: "#3498db",
          density: 2,
          fallSpeed: 2,
          spreadChance: 0.8,
          flammable: false,
          liquid: true,
          washesParticles: true,
          placementCost: 2,
          unlockCost: 50,
          baseValue: 0,
          reactions: ["sand", "fire", "oil"],
        },
        stone: {
          name: "⚫ Stone",
          color: "#5a5a5a",
          density: 10,
          fallSpeed: 0,
          spreadChance: 0,
          flammable: false,
          liquid: false,
          isPlatform: true,
          multiplier: 2,
          placementCost: 5,
          unlockCost: 100,
          baseValue: 0,
        },
        fire: {
          name: "🔥 Fire",
          color: "#e74c3c",
          density: 0,
          fallSpeed: -1,
          spreadChance: 0.2,
          flammable: false,
          liquid: false,
          lifetime: 180, // Longer lifetime for more reactions
          smelts: true,
          placementCost: 3,
          unlockCost: 200,
          baseValue: 0,
          reactions: ["sand", "water", "wood", "oil"],
        },
        wood: {
          name: "🟫 Wood",
          color: "#8b4513",
          density: 5,
          fallSpeed: 0.5,
          spreadChance: 0,
          flammable: true,
          liquid: false,
          placementCost: 4,
          unlockCost: 150,
          baseValue: 2,
          reactions: ["fire"],
        },
        oil: {
          name: "🟤 Oil",
          color: "#654321",
          density: 1,
          fallSpeed: 1,
          spreadChance: 0.9,
          flammable: true,
          liquid: true,
          lubricates: true,
          placementCost: 6,
          unlockCost: 300,
          baseValue: 3,
          reactions: ["fire", "water", "sand"],
        },
        steam: {
          name: "💨 Steam",
          color: "#ecf0f1",
          density: 0,
          fallSpeed: -1,
          spreadChance: 0.7,
          flammable: false,
          liquid: false,
          lifetime: 240,
          placementCost: 2,
          unlockCost: 250,
          baseValue: 1,
        },
        // New advanced materials
        ember: {
          name: "🔥 Ember",
          color: "#ff6b35",
          density: 3,
          fallSpeed: 0,
          spreadChance: 0,
          flammable: false,
          liquid: false,
          lifetime: 600, // 10 seconds
          generatesPassiveSand: true,
          placementCost: 0, // Cannot be placed directly
          unlockCost: 0,
          baseValue: 0,
          passiveGeneration: 0.1, // Sand per second
        },
        glass: {
          name: "💎 Glass",
          color: "#88ccff",
          density: 4,
          fallSpeed: 1,
          spreadChance: 0.3,
          flammable: false,
          liquid: false,
          placementCost: 0, // Cannot be placed directly
          unlockCost: 0,
          baseValue: 10, // High value
        },
        mud: {
          name: "🟤 Mud",
          color: "#8b6914",
          density: 4,
          fallSpeed: 0.3,
          spreadChance: 0.2,
          flammable: false,
          liquid: false,
          placementCost: 0,
          unlockCost: 0,
          baseValue: 3,
        },
        obsidian: {
          name: "⚫ Obsidian",
          color: "#2c3e50",
          density: 12,
          fallSpeed: 0,
          spreadChance: 0,
          flammable: false,
          liquid: false,
          isPlatform: true,
          multiplier: 5, // Higher multiplier than stone
          placementCost: 0,
          unlockCost: 0,
          baseValue: 20,
        },
        // Quantum Materials (unlocked after first prestige)
        void: {
          name: "🌌 Void",
          color: "#1a1a1a",
          density: 0,
          fallSpeed: 0,
          spreadChance: 0.1,
          flammable: false,
          liquid: false,
          absorbs: true, // Special property: absorbs nearby particles
          placementCost: 10,
          unlockCost: 0, // Unlocked via prestige
          baseValue: 5,
        },
        plasma: {
          name: "⚡ Plasma",
          color: "#ff00ff",
          density: 1,
          fallSpeed: -0.5,
          spreadChance: 0.8,
          flammable: false,
          liquid: false,
          converts: true, // Special property: converts particles to sand
          lifetime: 300,
          placementCost: 15,
          unlockCost: 0, // Unlocked via prestige
          baseValue: 0,
        },
        crystal: {
          name: "🔮 Crystal",
          color: "#00ffff",
          density: 8,
          fallSpeed: 0,
          spreadChance: 0,
          flammable: false,
          liquid: false,
          isPlatform: true,
          multiplier: 10, // Massive collection multiplier
          placementCost: 20,
          unlockCost: 0, // Unlocked via prestige
          baseValue: 0,
        },
      };

      // Material Reaction System - Enhanced meaningful interactions
      const materialReactions = {
        // Basic reactions
        "sand+water": {
          result: "mud",
          chance: 0.3,
          description: "Sand + Water = Mud (3x value)",
          discoveryBonus: 50,
        },
        "sand+fire": {
          result: "glass", 
          chance: 0.2,
          description: "Sand + Fire = Glass (10x value!)",
          discoveryBonus: 100,
        },
        "water+fire": {
          result: "steam",
          chance: 0.5,
          description: "Water + Fire = Steam",
          discoveryBonus: 25,
        },
        "wood+fire": {
          result: "ember",
          chance: 0.3,
          description: "Wood + Fire = Ember (passive income)",
          discoveryBonus: 75,
        },
        "oil+fire": {
          result: "explosion",
          chance: 0.4,
          description: "Oil + Fire = EXPLOSION! (Massive sand burst)",
          discoveryBonus: 200,
        },
        // Advanced reactions
        "sand+oil": {
          result: "enhanced_sand",
          chance: 0.4,
          description: "Sand + Oil = Enhanced Sand (2x value)",
          discoveryBonus: 30,
        },
        "stone+fire": {
          result: "obsidian",
          chance: 0.1,
          description: "Stone + Fire = Obsidian (5x multiplier platform)",
          discoveryBonus: 150,
        },
        "glass+water": {
          result: "crystal",
          chance: 0.05,
          description: "Glass + Water = Crystal (20x value)",
          discoveryBonus: 500,
        },
      };

      // Combo discovery tracking
      const comboDiscoveries = new Map();

       // Function to check and trigger reactions
       function triggerReaction(material1, material2, x, y) {
         const key1 = `${material1}+${material2}`;
         const key2 = `${material2}+${material1}`;
         
         const reaction = materialReactions[key1] || materialReactions[key2];
         if (!reaction) return false;

         // Apply reaction efficiency upgrade
         const reactionChance = reaction.chance * (upgrades.reactionEfficiency.level > 0 ? 
           upgrades.reactionEfficiency.effect(upgrades.reactionEfficiency.level) : 1);

         if (Math.random() < Math.min(reactionChance, 0.8)) { // Cap at 80% chance
           // Trigger reaction
           if (reaction.result === "explosion") {
             // Special explosion handling
              collectSand(25 * game.collectionMultiplier * getCatalystBonus());
             createExplosion(x, y);
           } else if (reaction.result === "enhanced_sand") {
             // Enhanced sand - create regular sand but mark it
             const particle = new Particle(x, y, "sand");
             particle.enhanced = true;
             particle.valueMultiplier = 2;
             game.grid[y][x] = particle;
           } else if (materials[reaction.result]) {
             // Create new material
             game.grid[y][x] = new Particle(x, y, reaction.result);
           }

           // Discovery bonus (first time only)
           const comboKey = key1 in materialReactions ? key1 : key2;
           if (!comboDiscoveries.has(comboKey)) {
             comboDiscoveries.set(comboKey, true);
              collectSand(reaction.discoveryBonus * getCatalystBonus());
             showDiscoveryNotification(reaction.description, reaction.discoveryBonus);
           }

           return true;
         }
         return false;
       }

      function createExplosion(x, y) {
        // Create fire particles in explosion radius
        for (let dy = -3; dy <= 3; dy++) {
          for (let dx = -3; dx <= 3; dx++) {
            const distance = Math.sqrt(dx*dx + dy*dy);
            if (distance <= 3 && Math.random() < 0.5) {
              const explosionX = x + dx;
              const explosionY = y + dy;
              if (explosionX >= 0 && explosionX < COLS && 
                  explosionY >= 0 && explosionY < ROWS &&
                  !game.grid[explosionY][explosionX]) {
                game.grid[explosionY][explosionX] = new Particle(explosionX, explosionY, "fire");
              }
            }
          }
        }
      }

       function showDiscoveryNotification(description, bonus) {
         // Create a visual notification for discoveries
         console.log(`🎉 DISCOVERY: ${description} (+${bonus} sand bonus!)`);
         
         // Create a temporary notification overlay
         const notification = document.createElement('div');
         notification.style.cssText = `
           position: fixed;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
           color: white;
           padding: 20px;
           border-radius: 10px;
           font-size: 18px;
           font-weight: bold;
           z-index: 1000;
           box-shadow: 0 4px 20px rgba(0,0,0,0.3);
           text-align: center;
           animation: fadeInOut 3s ease-in-out;
         `;
         
         notification.innerHTML = `
           <div style="font-size: 24px; margin-bottom: 10px;">🎉 NEW DISCOVERY! 🎉</div>
           <div style="margin-bottom: 10px;">${description}</div>
           <div style="color: #ffd700;">+${bonus} Sand Bonus!</div>
         `;
         
         document.body.appendChild(notification);
         
         // Remove after 3 seconds
         setTimeout(() => {
           if (notification.parentNode) {
             notification.parentNode.removeChild(notification);
           }
          }, 3000);
        }

        // Helper function to collect sand and track prestige progress
        function collectSand(amount) {
          game.sandCollected += amount;
          game.prestige.currentRunSand += amount;
          game.prestige.totalSandLifetime += amount;
        }

        // Calculate catalyst bonus
        function getCatalystBonus() {
          return 1 + (game.prestige.catalysts * 0.05);
        }

        // Calculate potential catalyst gain
        function calculateCatalystGain() {
          return Math.floor(game.prestige.totalSandLifetime / 1000);
        }

        // Prestige functions
        function canPrestige() {
          return game.sandCollected >= 10000;
        }

        function attemptPrestige() {
          if (!canPrestige()) {
            console.log("Need at least 10,000 sand to perform Dimensional Shift!");
            return;
          }

          const catalystGain = calculateCatalystGain() - game.prestige.catalysts;
          if (catalystGain <= 0) {
            console.log("No additional catalysts would be gained from prestige!");
            return;
          }

          if (confirm(`Perform Dimensional Shift?\n\nThis will reset all progress but grant ${catalystGain} Catalysts for +${catalystGain * 5}% permanent collection bonus.\n\nCurrent bonus: +${game.prestige.catalysts * 5}%\nNew bonus: +${calculateCatalystGain() * 5}%`)) {
            performPrestige();
          }
        }

        function performPrestige() {
          // Calculate and award catalysts
          const newCatalysts = calculateCatalystGain();
          game.prestige.catalysts = newCatalysts;
          game.prestige.hasPrestiged = true;

          // Reset everything except prestige data
          game.sandCollected = 50; // Give some starting sand after prestige
          game.prestige.currentRunSand = 0;
          game.currentMaterial = "sand";
          game.brushSize = 1;
          game.unlockedMaterials = new Set(["sand"]);
          
          // Reset grid
          game.grid = Array(ROWS).fill().map(() => Array(COLS).fill(null));
          
          // Reset idle mechanics
          game.autoClickers = 0;
          game.autoClickerTimer = 0;
          game.droppers = [];
          
          // Reset upgrades
          Object.values(upgrades).forEach(upgrade => {
            upgrade.level = 0;
          });

          // Reset research
          game.research = {
            autoCollection: 0,
            materialEfficiency: 0,
            reactionSpeed: 0,
            automation: 0
          };

          // Unlock quantum materials if this isn't the first prestige
          if (game.prestige.catalysts > 0) {
            game.unlockedMaterials.add("void");
            game.unlockedMaterials.add("plasma");
            game.unlockedMaterials.add("crystal");
          }

          console.log(`🌌 Dimensional Shift complete! Gained ${newCatalysts} Catalysts (+${newCatalysts * 5}% collection bonus)`);
        }

      // Particle class
      class Particle {
        constructor(x, y, type) {
          this.x = x;
          this.y = y;
          this.type = type;
          this.updated = false;
          this.lifetime = materials[type].lifetime || null;
          this.age = 0;
          this.washedBySand = false; // For water interaction bonus
          this.touchedWater = false; // Sand that touched water = 2x value
          this.touchedOil = false; // Sand that touched oil = faster fall
          this.smelted = false; // Fire + sand = glass
        }
      }

      // Dropper class
      class Dropper {
        constructor(x, type) {
          this.x = x;
          this.type = type;
          this.config = dropperTypes[type];
          this.frameCounter = 0;
        }

        update() {
          this.frameCounter++;
          if (this.frameCounter >= this.config.interval) {
            this.frameCounter = 0;
            this.drop();
          }
        }

        drop() {
          const col = Math.floor(this.x / CELL_SIZE);
          for (let i = 0; i < this.config.dropAmount; i++) {
            const targetCol = col + Math.floor(Math.random() * 3) - 1;
            if (
              targetCol >= 0 &&
              targetCol < COLS &&
              !game.grid[0][targetCol]
            ) {
              game.grid[0][targetCol] = new Particle(targetCol, 0, "sand");
            }
          }
        }

        render() {
          const x = this.x;
          const y = 10;

          // Draw dropper box
          ctx.fillStyle = this.config.color;
          ctx.fillRect(x - 10, y, 20, 15);
          ctx.strokeStyle = "#ffd700";
          ctx.lineWidth = 2;
          ctx.strokeRect(x - 10, y, 20, 15);

          // Draw icon
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(this.config.icon, x, y + 7);

          // Drop animation
          const progress = this.frameCounter / this.config.interval;
          if (progress > 0.8) {
            ctx.fillStyle = "#f4d03f";
            ctx.globalAlpha = 1 - (progress - 0.8) / 0.2;
            ctx.beginPath();
            ctx.arc(x, y + 15 + (progress - 0.8) * 50, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }
        }
      }

      // Mouse handling
      canvas.addEventListener("mousedown", (e) => {
        game.mouseDown = true;
        updateMousePos(e);
        placeMaterial();
      });

      canvas.addEventListener("mousemove", (e) => {
        updateMousePos(e);
        if (game.mouseDown) {
          placeMaterial();
        }
      });

      canvas.addEventListener("mouseup", () => {
        game.mouseDown = false;
      });

      canvas.addEventListener("mouseleave", () => {
        game.mouseDown = false;
      });

      function updateMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        game.mouseX = Math.floor((e.clientX - rect.left) / CELL_SIZE);
        game.mouseY = Math.floor((e.clientY - rect.top) / CELL_SIZE);
      }

      function placeMaterial() {
        const size = game.brushSize;
        const halfSize = Math.floor(size / 2);
        const particlesToPlace = game.clickPower;
        const material = materials[game.currentMaterial];
        const costPerParticle = material.placementCost;

        for (let i = 0; i < particlesToPlace; i++) {
          for (let dy = -halfSize; dy <= halfSize; dy++) {
            for (let dx = -halfSize; dx <= halfSize; dx++) {
              const x = game.mouseX + dx;
              const y = game.mouseY + dy;

              if (
                x >= 0 &&
                x < COLS &&
                y >= 0 &&
                y < ROWS &&
                !game.grid[y][x]
              ) {
                // Check if player can afford this material
                if (game.sandCollected >= costPerParticle) {
                  game.sandCollected -= costPerParticle;
                  game.grid[y][x] = new Particle(x, y, game.currentMaterial);
                }
              }
            }
          }
        }

        updateUI(); // Update UI to show sand being spent
      }

       // Upgrade system - Enhanced for idle mechanics
       function buyUpgrade(upgradeId) {
         const upgrade = upgrades[upgradeId];
         const cost = Math.floor(
           upgrade.baseCost * Math.pow(upgrade.costMultiplier, upgrade.level),
         );

         if (game.sandCollected >= cost) {
           game.sandCollected -= cost;
           upgrade.level++;

           // Apply upgrade effects
           if (upgradeId === "autoClicker") {
             game.autoClickers = upgrade.effect(upgrade.level);
             console.log(`Auto-clickers now: ${game.autoClickers}`);
           } else if (upgradeId === "clickPower") {
             game.clickPower = upgrade.effect(upgrade.level);
           } else if (upgradeId === "collectionMultiplier") {
             game.collectionMultiplier = upgrade.effect(upgrade.level);
           } else if (upgradeId === "collectionSpeed") {
             game.collectionSpeed = upgrade.effect(upgrade.level);
           } else if (upgradeId === "reactionEfficiency") {
             // Affects reaction rates in the physics update
           } else if (upgradeId === "automationSpeed") {
             // Affects dropper and auto-clicker speeds
             const speedMultiplier = upgrade.effect(upgrade.level);
             game.autoClickerSpeed = Math.max(30, Math.floor(180 * speedMultiplier));
           }

           renderUpgrades();
           updateUI();
           console.log(`Purchased ${upgradeId} level ${upgrade.level} for ${cost} sand`);
         }
       }

       function renderUpgrades() {
         const container = document.getElementById("upgradesContainer");
         if (!container) {
           console.error("Upgrades container not found!");
           return;
         }
         
         container.innerHTML = "";

         Object.entries(upgrades).forEach(([id, upgrade]) => {
           const cost = Math.floor(
             upgrade.baseCost * Math.pow(upgrade.costMultiplier, upgrade.level),
           );
           const canAfford = game.sandCollected >= cost;

           const btn = document.createElement("button");
           btn.className = "upgrade-btn";
           btn.disabled = !canAfford;
           btn.innerHTML = `
                     <div class="upgrade-btn-content">
                         <div class="upgrade-header">
                             <span>${upgrade.icon} ${upgrade.name}</span>
                             <span class="upgrade-level">Lv ${upgrade.level}</span>
                         </div>
                         <div class="upgrade-desc">${upgrade.description}</div>
                         <div class="upgrade-cost">Cost: ${cost} sand</div>
                     </div>
                 `;
           btn.onclick = () => buyUpgrade(id);
           container.appendChild(btn);
         });
         
         console.log(`Rendered ${Object.keys(upgrades).length} upgrades`);
       }

      // Dropper system
      function buyDropper(type) {
        const config = dropperTypes[type];
        if (game.sandCollected >= config.cost) {
          game.sandCollected -= config.cost;

          // Place dropper at random position
          const x = 50 + Math.random() * (canvas.width - 100);
          game.droppers.push(new Dropper(x, type));

          renderDroppers();
          updateUI();
        }
      }

      function renderDroppers() {
        const container = document.getElementById("droppersContainer");
        container.innerHTML = "";

        Object.entries(dropperTypes).forEach(([id, config]) => {
          const count = game.droppers.filter((d) => d.type === id).length;
          const canAfford = game.sandCollected >= config.cost;

          const btn = document.createElement("button");
          btn.className = "dropper-btn";
          btn.disabled = !canAfford;
          btn.innerHTML = `
                    <span>${config.icon} ${config.name} (${count})</span>
                    <span class="material-cost">${config.cost} sand</span>
                `;
          btn.onclick = () => buyDropper(id);
          container.appendChild(btn);
        });
      }

       // Update material button displays based on materials object
       function updateMaterialButtons() {
         document.querySelectorAll(".material-btn").forEach((btn) => {
           const material = btn.dataset.material;
           if (materials[material]) {
             const mat = materials[material];
             const costSpan = btn.querySelector('.material-cost');
             if (costSpan) {
               costSpan.textContent = mat.unlockCost > 0 ? `${mat.unlockCost} sand` : 'Free';
         }
      }
         });
       }

       // Material buttons
       document.querySelectorAll(".material-btn").forEach((btn) => {
         btn.addEventListener("click", () => {
           const material = btn.dataset.material;
           const cost = materials[material] ? materials[material].unlockCost : 0;

           if (game.unlockedMaterials.has(material)) {
             selectMaterial(material);
           } else if (game.sandCollected >= cost) {
             // Unlock material
             game.sandCollected -= cost;
             game.unlockedMaterials.add(material);
             btn.classList.remove("locked");
             selectMaterial(material);
             updateUI();
           }
         });
       });

      function selectMaterial(material) {
        game.currentMaterial = material;
        document.querySelectorAll(".material-btn").forEach((btn) => {
          btn.classList.remove("selected");
        });
        const btn = document.querySelector(`[data-material="${material}"]`);
        if (btn) {
          btn.classList.add("selected");
          const mat = materials[material];
          const costText =
            mat.placementCost > 0
              ? ` (${mat.placementCost} sand/use)`
              : " (Free)";
          document.getElementById("materialName").textContent =
            mat.name + costText;
        }
      }

      // Brush size
      document.getElementById("brushSize").addEventListener("input", (e) => {
        game.brushSize = parseInt(e.target.value);
        document.getElementById("brushSizeValue").textContent = game.brushSize;
      });

      // Clear button
      document.getElementById("clearBtn").addEventListener("click", () => {
        game.grid = Array(ROWS)
          .fill()
          .map(() => Array(COLS).fill(null));
      });

      // Physics simulation
      function updatePhysics() {
        // Reset updated flags
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            if (game.grid[y][x]) {
              game.grid[y][x].updated = false;
            }
          }
        }

        // Process from bottom to top
        for (let y = ROWS - 1; y >= 0; y--) {
          for (let x = 0; x < COLS; x++) {
            const particle = game.grid[y][x];
            if (!particle || particle.updated) continue;

            const mat = materials[particle.type];
            particle.updated = true;
            particle.age++;

            // Handle lifetime
            if (particle.lifetime && particle.age >= particle.lifetime) {
              game.grid[y][x] = null;
              continue;
            }

            // Movement based on density and type
            if (mat.fallSpeed > 0) {
              // Check for material interactions before moving
              checkMaterialInteractions(particle, x, y);

              // Try to fall down first
              if (tryMove(particle, x, y, 0, 1)) continue;

              // If can't fall, try to spread
              if (mat.liquid && Math.random() < mat.spreadChance) {
                // Liquids spread horizontally when they can't fall
                const dir = Math.random() < 0.5 ? -1 : 1;
                if (!tryMove(particle, x, y, dir, 0)) {
                  tryMove(particle, x, y, -dir, 0);
                }
              } else if (
                mat.spreadChance > 0 &&
                Math.random() < mat.spreadChance
              ) {
                // Granular materials (sand) try to fall diagonally
                const dir = Math.random() < 0.5 ? -1 : 1;
                if (!tryMove(particle, x, y, dir, 1)) {
                  tryMove(particle, x, y, -dir, 1);
                }
              }
            }

            // Collect materials from the very bottom row (collection zone)
            if (y === ROWS - 1 && Math.random() < game.collectionSpeed) {
              let collectionValue = game.collectionMultiplier;

               // Calculate bonuses based on material type and interactions
               const material = materials[particle.type];
               let baseValue = material.baseValue || 0;
               
               if (particle.type === "sand") {
                 baseValue = 1; // Sand always has base value of 1
                 if (particle.enhanced) {
                   collectionValue *= particle.valueMultiplier || 2;
                 }
                 if (particle.touchedWater) {
                   collectionValue *= 2; // Washed sand = 2x
                 }
                 if (particle.touchedOil) {
                   collectionValue *= 1.5; // Lubricated sand = 1.5x
                 }

                 // Check if there's a stone platform nearby for multiplier
                 let platformMultiplier = 1;
                 for (let checkX = Math.max(0, x - 2); checkX <= Math.min(COLS - 1, x + 2); checkX++) {
                   if (game.grid[y][checkX] && materials[game.grid[y][checkX].type].isPlatform) {
                     const platMaterial = materials[game.grid[y][checkX].type];
                     platformMultiplier = Math.max(platformMultiplier, platMaterial.multiplier || 1);
                   }
                 }
                 collectionValue *= platformMultiplier;

                  collectSand(collectionValue * baseValue * getCatalystBonus());
                 game.grid[y][x] = null;
               } else if (baseValue > 0) {
                 // Other valuable materials
                  collectSand(collectionValue * baseValue * getCatalystBonus());
                 game.grid[y][x] = null;
               } else if (particle.type === "stone" || particle.type === "obsidian") {
                 // Platforms stay at bottom as permanent platforms
                 // Don't remove them
               } else {
                 // Remove other particles that reach bottom but have no value
                 game.grid[y][x] = null;
               }
            }

            // Ember passive generation (anywhere on screen)
            if (particle.type === "ember" && Math.random() < 0.01) {
              collectSand(game.collectionMultiplier * 0.1 * getCatalystBonus());
            } else if (mat.fallSpeed < 0) {
              // Rising particles (fire, steam)
              if (tryMove(particle, x, y, 0, -1)) continue;

              if (Math.random() < mat.spreadChance) {
                const dir = Math.random() < 0.5 ? -1 : 1;
                tryMove(particle, x, y, dir, -1) ||
                  tryMove(particle, x, y, dir, 0);
              }
            }

            // Fire interactions
            if (particle.type === "fire") {
              // Fire spreads to adjacent flammable materials
              for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                  const nx = x + dx;
                  const ny = y + dy;
                  if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                    const neighbor = game.grid[ny][nx];
                    if (
                      neighbor &&
                      materials[neighbor.type].flammable &&
                      Math.random() < 0.1
                    ) {
                      game.grid[ny][nx] = new Particle(nx, ny, "fire");
                    }
                    // Water extinguishes fire
                    if (neighbor && neighbor.type === "water") {
                      game.grid[y][x] = null;
                      game.grid[ny][nx] = new Particle(nx, ny, "steam");
                    }
                  }
                }
              }
            }

            // Water + Fire = Steam
            if (particle.type === "water") {
              for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                  const nx = x + dx;
                  const ny = y + dy;
                  if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                    const neighbor = game.grid[ny][nx];
                    if (
                      neighbor &&
                      neighbor.type === "fire" &&
                      Math.random() < 0.3
                    ) {
                      game.grid[y][x] = new Particle(x, y, "steam");
                      game.grid[ny][nx] = null;
                    }
                  }
                }
              }
            }
          }
        }
      }

      // Check for material interactions - Enhanced with new reaction system
      function checkMaterialInteractions(particle, x, y) {
        const reactionSpeedMultiplier = upgrades.reactionEfficiency.level > 0 ? 
          upgrades.reactionEfficiency.effect(upgrades.reactionEfficiency.level) : 1;

        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;

            const nx = x + dx;
            const ny = y + dy;
            if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;

            const neighbor = game.grid[ny][nx];
            if (!neighbor) continue;

            // Try the new reaction system first
            if (triggerReaction(particle.type, neighbor.type, x, y)) {
              // Remove the neighbor particle that was consumed in the reaction
              game.grid[ny][nx] = null;
              return; // Exit early since particle was transformed
            }

            // Legacy interaction effects for materials that don't have full reactions
            if (particle.type === "sand" && neighbor.type === "water") {
              particle.touchedWater = true;
            }

            if (particle.type === "sand" && neighbor.type === "oil") {
              particle.touchedOil = true;
            }
          }
        }
      }

      function tryMove(particle, x, y, dx, dy) {
        const nx = x + dx;
        const ny = y + dy;

        if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) return false;

        const target = game.grid[ny][nx];

        if (!target) {
          // Empty space - move there
          game.grid[ny][nx] = particle;
          game.grid[y][x] = null;
          particle.x = nx;
          particle.y = ny;
          return true;
        } else {
          // Check density - denser particles can displace lighter ones
          const particleMat = materials[particle.type];
          const targetMat = materials[target.type];

          if (particleMat.density > targetMat.density) {
            // Swap
            game.grid[ny][nx] = particle;
            game.grid[y][x] = target;
            particle.x = nx;
            particle.y = ny;
            target.x = x;
            target.y = y;
            return true;
          }
        }

        return false;
      }

      // Update droppers
      function updateDroppers() {
        game.droppers.forEach((dropper) => dropper.update());
      }

      // Render
      function render() {
        ctx.fillStyle = "#16213e";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw particles
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const particle = game.grid[y][x];
            if (particle) {
              const mat = materials[particle.type];
              ctx.fillStyle = mat.color;

              // Visual variations based on interactions
              if (particle.type === "sand") {
                if (particle.touchedWater) {
                  ctx.fillStyle = "#d4af37"; // Golden sand (washed)
                } else if (particle.touchedOil) {
                  ctx.fillStyle = "#aa8844"; // Darker oily sand
                }
              }

              // Add some variation for fire
              if (particle.type === "fire") {
                const colors = ["#e74c3c", "#f39c12", "#f1c40f"];
                ctx.fillStyle =
                  colors[Math.floor(Math.random() * colors.length)];
              }

              // Ember glow effect
              if (particle.type === "ember") {
                const glowColors = ["#ff6b35", "#f7931e", "#ff4500"];
                ctx.fillStyle =
                  glowColors[Math.floor(Math.random() * glowColors.length)];
              }

              ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);

              // Add sparkle effect to glass
              if (particle.type === "glass" && Math.random() < 0.3) {
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, 1, 1);
              }
            }
          }
        }

        // Draw droppers
        game.droppers.forEach((dropper) => dropper.render());

        // Draw brush preview
        if (
          game.mouseX >= 0 &&
          game.mouseX < COLS &&
          game.mouseY >= 0 &&
          game.mouseY < ROWS
        ) {
          const material = materials[game.currentMaterial];
          const canAfford = game.sandCollected >= material.placementCost;

          ctx.strokeStyle = canAfford
            ? "rgba(255, 255, 255, 0.5)"
            : "rgba(255, 100, 100, 0.8)";
          ctx.lineWidth = canAfford ? 1 : 2;
          const size = game.brushSize;
          const halfSize = Math.floor(size / 2);
          ctx.strokeRect(
            (game.mouseX - halfSize) * CELL_SIZE,
            (game.mouseY - halfSize) * CELL_SIZE,
            size * CELL_SIZE,
            size * CELL_SIZE,
          );
        }
      }

      // Track sand per second
      function updateSandPerSec() {
        const currentSand = game.sandCollected;
        game.sandPerSecTracker.push(currentSand - game.lastSandCount);
        game.lastSandCount = currentSand;

        // Keep only last 10 seconds of data
        if (game.sandPerSecTracker.length > 60) {
          game.sandPerSecTracker.shift();
        }

        // Calculate average
        const total = game.sandPerSecTracker.reduce((a, b) => a + b, 0);
        const average = total / (game.sandPerSecTracker.length / 60);

        document.getElementById("sandPerSec").textContent = average.toFixed(1);
      }

       // Update UI
       function updateUI() {
         document.getElementById("sandCount").textContent = Math.floor(
           game.sandCollected,
         );

         const autoClickerElement = document.getElementById("autoClickerCount");
         if (autoClickerElement) {
           autoClickerElement.textContent = game.autoClickers;
         }

         let particleCount = 0;
         for (let y = 0; y < ROWS; y++) {
           for (let x = 0; x < COLS; x++) {
             if (game.grid[y][x]) particleCount++;
           }
         }
          document.getElementById("particleCount").textContent = particleCount;

          // Update prestige UI
          const catalystElement = document.getElementById("catalystCount");
          if (catalystElement) {
            catalystElement.textContent = game.prestige.catalysts;
          }

          const bonusElement = document.getElementById("collectionBonus");
          if (bonusElement) {
            bonusElement.textContent = `+${(game.prestige.catalysts * 5).toFixed(1)}%`;
          }

          const lifetimeElement = document.getElementById("totalSandLifetime");
          if (lifetimeElement) {
            lifetimeElement.textContent = Math.floor(game.prestige.totalSandLifetime);
          }

          const prestigeButton = document.getElementById("prestigeButton");
          const prestigeGain = document.getElementById("prestigeGain");
          if (prestigeButton && prestigeGain) {
            const canPerformPrestige = canPrestige();
            const catalystGain = Math.max(0, calculateCatalystGain() - game.prestige.catalysts);
            
            prestigeGain.textContent = catalystGain;
            
            if (canPerformPrestige && catalystGain > 0) {
              prestigeButton.classList.remove("disabled");
            } else {
              prestigeButton.classList.add("disabled");
            }
          }
       }

       // Auto-clicker functionality
       function updateAutoClickers() {
         if (game.autoClickers > 0) {
           game.autoClickerTimer++;
           if (game.autoClickerTimer >= game.autoClickerSpeed) {
             game.autoClickerTimer = 0;
             
             // Auto-click at random locations
             for (let i = 0; i < game.autoClickers; i++) {
               const randomX = Math.floor(Math.random() * COLS);
               const randomY = Math.floor(Math.random() * (ROWS - 10)) + 5; // Avoid top and bottom
               
               // Simulate placing sand at this location
               if (!game.grid[randomY][randomX]) {
                 game.grid[randomY][randomX] = new Particle(randomX, randomY, "sand");
               }
             }
             
             if (game.autoClickers > 0 && frameCount % 300 === 0) {
               console.log(`Auto-clickers working: ${game.autoClickers} clickers, speed: ${game.autoClickerSpeed}`);
             }
                }
              }
            }

            // Quantum Material Special Behaviors
            if (particle.type === "void") {
              // Void absorbs nearby particles and grows larger
              for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                  const nx = x + dx;
                  const ny = y + dy;
                  if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && (dx !== 0 || dy !== 0)) {
                    const neighbor = game.grid[ny][nx];
                    if (neighbor && neighbor.type !== "void" && Math.random() < 0.05) {
                      game.grid[ny][nx] = null;
                      collectSand(materials[neighbor.type].baseValue * 2 * getCatalystBonus());
                      // Randomly spawn more void particles nearby
                      if (Math.random() < 0.1) {
                        const voidX = x + Math.floor(Math.random() * 3) - 1;
                        const voidY = y + Math.floor(Math.random() * 3) - 1;
                        if (voidX >= 0 && voidX < COLS && voidY >= 0 && voidY < ROWS && !game.grid[voidY][voidX]) {
                          game.grid[voidY][voidX] = new Particle(voidX, voidY, "void");
                        }
                      }
                    }
                  }
                }
              }
            }

            if (particle.type === "plasma") {
              // Plasma converts other particles into sand rapidly
              for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                  const nx = x + dx;
                  const ny = y + dy;
                  if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && (dx !== 0 || dy !== 0)) {
                    const neighbor = game.grid[ny][nx];
                    if (neighbor && neighbor.type !== "plasma" && Math.random() < 0.3) {
                      const baseValue = materials[neighbor.type].baseValue || 1;
                      collectSand(baseValue * 3 * getCatalystBonus());
                      game.grid[ny][nx] = new Particle(nx, ny, "sand");
                    }
                  }
                }
              }
            }

      // Update ember passive generation
      function updatePassiveGeneration() {
        let passiveIncome = 0;
        
        // Count ember particles and generate passive sand
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const particle = game.grid[y][x];
            if (particle && particle.type === "ember") {
              passiveIncome += materials.ember.passiveGeneration;
            }
          }
        }
        
         if (passiveIncome > 0) {
            collectSand(passiveIncome * game.collectionMultiplier * getCatalystBonus());
         }
       }

      // Game loop - Enhanced for idle mechanics
      let frameCount = 0;
      function gameLoop() {
        frameCount++;

        // Update physics every frame
        updatePhysics();

        // Update droppers
        updateDroppers();

        // Update auto-clickers
        updateAutoClickers();

        // Update passive generation every second
        if (frameCount % 60 === 0) {
          updatePassiveGeneration();
        }

        // Render
        render();

        // Update UI less frequently
        if (frameCount % 10 === 0) {
          updateUI();
        }

        // Update sand per second and render upgrades/droppers
        if (frameCount % 60 === 0) {
          updateSandPerSec();
          renderUpgrades();
          renderDroppers();
        }

        requestAnimationFrame(gameLoop);
      }

       // Start game
       updateMaterialButtons();
       renderUpgrades();
       renderDroppers();
       updateUI();
       gameLoop();
    </script>
  </body>
</html>
